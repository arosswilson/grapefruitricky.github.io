<!DOCTYPE html>
<html>
<head>
  <title>Enumerables Cheat Sheet</title>
   <link rel="stylesheet" type="text/css" href="../stylesheets/cheat-sheet.css">
</head>

<body >
  <h1> Enumberables Cheat Sheet</h1>
  <div id="description">Here is a list of the enumerable methods in Ruby. This will list out each method, hopefully give a clear description of what it does, and an example.
    <p>
      <ul>
        <li></li>
        <li>link2</li>
      </ul>
    </p>
  </div>

  <div id="method_one">
    <h2>Method 1: Inject</h2>
    <p>.inject is a method that takes two arguments in the block. The first argument is the value that is returned each time an element is passed through the block. The second arugment is the variable for each element that you'll pass through the block. Each time an element is passed throught the block, the first argument is updated. To illustrate this, we can use inject to quickly sum a range of numbers:</p>

     <p>(5..8).inject {|sum, n| sum + n} => 26</p>

     <p>Here, inject takes the first value in the range (5) as the sum and starts with the next value as n(6). You can control what inject starts with as the first argument in the block, by adding an argument after inject. For example:</p>

     <p> (5..8).inject(5) {|sum, n| sum + n} => 31</p>.

     <p>In this example, sum is starting as 5 and n initially is 5.</p>

   </div>
  <div id="method_two">
    <h2>Method 2: Lazy</h2>

      <p>.Lazy is a method that is based of the programming concept of 'lazy evaluation'. The concept is basically that an evaluation of an experssion doesn't corru until it's value is needed. What this means for Ruby is that you can take a range of (1..Float::INFINITY) and add an additional method to evaluate some of the values. For example:
      </p>

     <p>5.times do
          array = []
         (1..Float::INFINITY).lazy.each do |x|
           array << (x + 2)
         end
        end
      </p>
    <p>
      if the lazy method wasn't added to the expression, then the range would be evaluated immediately and cause your program to crash.
    </p>
  </div>
  <div id="method_three">
    <h2>Method 3: Reduce<h2>
      <p>.reduce combines all elements of your enumerable by applying a binary operation, specified by a block or a symbol that names a method or operator. It's particularly helpful in quick math operations between a range of arbitrary numbers, or an array with a series of numbers (like in the validate a credit card challenge we completed in Ruby). It takes a collection and "reduces" it down to a single element. It applies an operation to each element, maintaining a running "total".
      </p>

      <p>Example 1:</p>

    <p>array = [1,2,3,4,5,6]
         array.reduce(:+)
         => 21 which is the sum of 1+2+3+4+5+6
        array.reduce(:*)
         => 720 which is the product of 1+2+3+4+5+6
      </p>

      <p>Example 2:</p>
      <p>(1..5).reduce(:+)
        => 15 which is the sum of 1+2+3+4+5
         (1..5).reduce(:*)
        => 120 which is the product of 1+2+3+4+5
      </p>

      <p>In summary, .reduce allows you to perform a mathematical operation quickly on your enumerable.
      </p>
    </div>
    <div id="method_four">
        <h2>Method 4: Select<h2>
      <p>.select returns an array containing all elements of enum for which the given block returns a true value. If no block is given, an Enumerator is returned instead. What this means in laymens terms is that the .select methoed allows you to execute whatever code inside your curly {} brackets tells the computer to, so long as it's true. It's particularly helpful in letting you manipulate specific elements inside arrays.
      </p>

      <p>Example 1:</p>

    <p>array = [1,2,3,4,5,6]
         array.select {|e| e.even? }
         => [2,4,6]
         Note that this method is not destructive, which means that if you call your array variable in ruby, it will still return the original array. Using ".select!" however will transform your existing variable into whatever the code block inside the curly brackets returns. So in this example array will now equal [2,4,6], since that's the code you had inside your curly brackets.
      </p>

      <p>Example 2:</p>
      <p>array = ["Eric", "Ross", "Imaginary Friend"]
        array.select {|e| e.include?("Ross")}
        =>
        ["Ross"]
        Note that this method is not destructive, which means that if you call your array variable, it will still return an array with three strings. Using ".select!" however will transform your existing variable into whatever the code block inside the curly brackets returns. So in this example array will now equal ["Ross"].
      </p>

      <p>In summary, .select allows you to "select" or "filter" through your enumerable based on whatever code you pass inside the curly brackets.
      </p>

  </div>

</body>
</html>
